Origin: http://cgit.freedesktop.org/accountsservice/patch/?id=ba13b59cb91ec67c86b3e3fb390d91db01df8963
Forwarded: not-needed
Description: This patch is a reversion of upstream commit linked above.  Ubuntu would still like to support login.defs, which is used in at least Ubuntu Touch.

Index: accountsservice-0.6.37/configure.ac
===================================================================
--- accountsservice-0.6.37.orig/configure.ac
+++ accountsservice-0.6.37/configure.ac
@@ -56,17 +56,11 @@ AS_IF([test x$enable_admin_group = xauto
 AC_DEFINE_UNQUOTED([ADMIN_GROUP], ["$enable_admin_group"], [Define to the group for administrator users])
 
 AC_ARG_ENABLE(user-heuristics,
-        [AS_HELP_STRING([--enable-user-heuristics],[Enable heuristics for guessing system vs. human users in the range 500-minimum-uid])],
+        [AS_HELP_STRING([--enable-user-heuristics],[Enable heuristics for guessing system vs. human users])],
         [if test "$enableval" = yes; then
            AC_DEFINE([ENABLE_USER_HEURISTICS], , [System vs. human user heuristics enabled])
         fi])
 
-AC_ARG_WITH(minimum-uid,
-        [AS_HELP_STRING([--with-minimum-uid],[Set minimum uid for human users])],
-        ,with_minimum_uid=1000)
-
-AC_DEFINE_UNQUOTED([MINIMUM_UID], $with_minimum_uid, [Define to the minumum UID of human users])
-
 dnl ---------------------------------------------------------------------------
 dnl - coverage
 dnl ---------------------------------------------------------------------------
Index: accountsservice-0.6.37/src/user-classify.c
===================================================================
--- accountsservice-0.6.37.orig/src/user-classify.c
+++ accountsservice-0.6.37/src/user-classify.c
@@ -26,6 +26,7 @@
 
 #include <string.h>
 
+#ifdef ENABLE_USER_HEURISTICS
 static const char *default_excludes[] = {
         "bin",
         "root",
@@ -56,10 +57,16 @@ static const char *default_excludes[] =
         "gnome-initial-setup"
 };
 
+#define PATH_NOLOGIN "/sbin/nologin"
+#define PATH_FALSE "/bin/false"
+
 static gboolean
-user_classify_is_blacklisted (const char *username)
+user_classify_is_excluded_by_heuristics (const gchar *username,
+                                         const gchar *shell,
+                                         const gchar *password_hash)
 {
         static GHashTable *exclusions;
+        gboolean ret = FALSE;
 
         if (exclusions == NULL) {
                 guint i;
@@ -75,20 +82,6 @@ user_classify_is_blacklisted (const char
                 return TRUE;
         }
 
-        return FALSE;
-}
-
-#define PATH_NOLOGIN "/sbin/nologin"
-#define PATH_FALSE "/bin/false"
-
-#ifdef ENABLE_USER_HEURISTICS
-static gboolean
-user_classify_is_excluded_by_heuristics (const gchar *username,
-                                         const gchar *shell,
-                                         const gchar *password_hash)
-{
-        gboolean ret = FALSE;
-
         if (shell != NULL) {
                 char *basename, *nologin_basename, *false_basename;
 
@@ -146,6 +139,99 @@ user_classify_is_excluded_by_heuristics
 
         return ret;
 }
+
+#else /* ENABLE_USER_HEURISTICS */
+
+static gboolean
+user_classify_parse_login_defs_field (const gchar *contents,
+                                      const gchar *key,
+                                      uid_t       *result)
+{
+        gsize key_len;
+        gint64 value;
+        gchar *end;
+
+        key_len = strlen (key);
+
+        for (;;) {
+                /* Our key has to be at the start of the line, followed by whitespace */
+                if (strncmp (contents, key, key_len) == 0 && g_ascii_isspace (contents[key_len])) {
+                        /* Found it.  Move contents past the key itself and break out. */
+                        contents += key_len;
+                        break;
+                }
+
+                /* Didn't find it.  Find the end of the line. */
+                contents = strchr (contents, '\n');
+
+                /* EOF? */
+                if (!contents) {
+                        /* We didn't find the field... */
+                        return FALSE;
+                }
+
+                /* Start at the beginning of the next line on next iteration. */
+                contents++;
+        }
+
+        /* 'contents' now points at the whitespace character just after
+         * the field name.  strtoll can deal with that.
+         */
+        value = g_ascii_strtoll (contents, &end, 10);
+
+        if (*end && !g_ascii_isspace (*end)) {
+                g_warning ("Trailing junk after '%s' field in login.defs", key);
+                return FALSE;
+        }
+
+        if (value <= 0 || value >= G_MAXINT32) {
+                g_warning ("Value for '%s' field out of range", key);
+                return FALSE;
+        }
+
+        *result = value;
+
+        return TRUE;
+}
+
+static void
+user_classify_read_login_defs (uid_t *min_uid)
+{
+        GError *error = NULL;
+        char *contents;
+
+        if (!g_file_get_contents ("/etc/login.defs", &contents, NULL, &error)) {
+                g_warning ("Could not open /etc/login.defs: %s.  Falling back to default minimum human uid of %d",
+                           error->message, (int) *min_uid);
+                g_error_free (error);
+                return;
+        }
+
+        if (!user_classify_parse_login_defs_field (contents, "UID_MIN", min_uid)) {
+                g_warning ("Could not find UID_MIN value in login.defs.  Using default of %d", (int) *min_uid);
+        }
+
+        g_free (contents);
+}
+
+static gboolean
+user_classify_is_in_human_range (const gchar *username,
+                                 uid_t uid)
+{
+        static uid_t min_uid = 1000;
+        static gboolean initialised;
+
+        if (!initialised) {
+                user_classify_read_login_defs (&min_uid);
+                initialised = TRUE;
+        }
+
+        /* There are a few system accounts that are outside UID_MIN - ignore them */
+        if (strcmp (username, "nobody") == 0 || strcmp (username, "nfsnobody") == 0)
+                return FALSE;
+
+        return uid >= min_uid;
+}
 #endif /* ENABLE_USER_HEURISTICS */
 
 gboolean
@@ -154,16 +240,9 @@ user_classify_is_human (uid_t        uid
                         const gchar *shell,
                         const gchar *password_hash)
 {
-        if (user_classify_is_blacklisted (username))
-                return FALSE;
-
 #ifdef ENABLE_USER_HEURISTICS
-        /* only do heuristics on the range 500-1000 to catch one off migration problems in Fedora */
-        if (uid >= 500 && uid < MINIMUM_UID) {
-                if (!user_classify_is_excluded_by_heuristics (username, shell, password_hash))
-                        return TRUE;
-        }
+        return !user_classify_is_excluded_by_heuristics (username, shell, password_hash);
+#else
+        return user_classify_is_in_human_range (username, uid);
 #endif
-
-        return uid >= MINIMUM_UID;
 }
